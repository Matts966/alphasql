//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// LINT: LEGACY_NAMES

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLFunction";

// A unique ID for ZetaSQL function signatures.  Resolved ZetaSQL functions
// will provide one of these enums, and ZetaSQL implementations should map
// them to something they can evaluate.
enum FunctionSignatureId {
  // User code that switches on this enum must have a default case so
  // builds won't break if new enums get added.
  __FunctionSignatureId__switch_must_have_a_default__ = -1;

  FN_INVALID_FUNCTION_ID = 1;

  // The first set of functions do not use standard function call syntax,
  // reflecting operators, functions with infix notation (LIKE), and
  // other special functions (CASE).  FunctionSignatureIds are assigned
  // in ranges:
  //
  // 0002-0999 Non-standard function calls   (NextId: 266)
  // 1000-1099 String functions              (NextId: 1069)
  // 1100-1199 Control flow functions        (NextId: 1104)
  // 1200-1299 Time functions                (Fully used)
  // 1300-1399 Math functions                (Fully used)
  // 1400-1499 Aggregate functions           (NextId: 1481)
  // 1500-1599 Analytic functions            (NextId: 1513)
  // 1600-1699 Misc functions                (NextId: 1684)
  // 1700-1799 Net functions                 (NextId: 1716)
  // 1800-1899 More time functions           (NextId: 1833)
  // 1900-1999 Hashing/encryption functions  (NextId: 1924)
  // 2000-2199 Geography functions           (NextId: 2065)
  // 2300-2499 More math functions           (NextId: 2303)

  // enum value                       // Related function name
  // ----------                       // ---------------------
  FN_ADD_DOUBLE = 2;                       // $add
  FN_ADD_INT64 = 4;                        // $add
  FN_ADD_UINT64 = 119;                     // $add
  FN_ADD_NUMERIC = 248;                    // $add
  FN_ADD_BIGNUMERIC = 261;                 // $add
  FN_AND = 5;                              // $and
  FN_CASE_NO_VALUE = 6;                    // $case_no_value
  FN_CASE_WITH_VALUE = 7;                  // $case_with_value
  FN_DIVIDE_DOUBLE = 40;                   // $divide
  FN_DIVIDE_NUMERIC = 250;                 // $divide
  FN_DIVIDE_BIGNUMERIC = 263;              // $divide
  FN_GREATER = 107;                        // $greater
  FN_GREATER_INT64_UINT64 = 222;           // $greater
  FN_GREATER_UINT64_INT64 = 223;           // $greater
  FN_GREATER_OR_EQUAL = 108;               // $greater_or_equal
  FN_GREATER_OR_EQUAL_INT64_UINT64 = 224;  // $greater_or_equal
  FN_GREATER_OR_EQUAL_UINT64_INT64 = 225;  // $greater_or_equal
  FN_LESS = 105;                           // $less
  FN_LESS_INT64_UINT64 = 226;              // $less
  FN_LESS_UINT64_INT64 = 227;              // $less
  FN_LESS_OR_EQUAL = 106;                  // $less_or_equal
  FN_LESS_OR_EQUAL_INT64_UINT64 = 228;     // $less_or_equal
  FN_LESS_OR_EQUAL_UINT64_INT64 = 229;     // $less_or_equal
  FN_EQUAL = 42;                           // $equal
  FN_EQUAL_INT64_UINT64 = 230;             // $equal
  FN_EQUAL_UINT64_INT64 = 231;             // $equal
  FN_STRING_LIKE = 97;                     // $like
  FN_BYTE_LIKE = 98;                       // $like
  FN_IN = 100;                             // $in
  FN_IN_ARRAY = 219;                       // $in_array
  FN_BETWEEN = 110;                        // $between
  FN_BETWEEN_INT64_UINT64_UINT64 = 254;    // $between
  FN_BETWEEN_INT64_UINT64_INT64 = 255;     // $between
  FN_BETWEEN_INT64_INT64_UINT64 = 256;     // $between
  FN_BETWEEN_UINT64_INT64_INT64 = 257;     // $between
  FN_BETWEEN_UINT64_UINT64_INT64 = 258;    // $between
  FN_BETWEEN_UINT64_INT64_UINT64 = 259;    // $between
  FN_IS_NULL = 101;                        // $is_null
  FN_IS_TRUE = 102;                        // $is_true
  FN_IS_FALSE = 103;                       // $is_false
  FN_MULTIPLY_DOUBLE = 41;                 // $multiply
  FN_MULTIPLY_INT64 = 44;                  // $multiply
  FN_MULTIPLY_UINT64 = 114;                // $multiply
  FN_MULTIPLY_NUMERIC = 251;               // $multiply
  FN_MULTIPLY_BIGNUMERIC = 264;            // $multiply
  FN_NOT = 45;                             // $not
  FN_NOT_EQUAL = 109;                      // $not_equal
  FN_NOT_EQUAL_INT64_UINT64 = 232;         // $not_equal
  FN_NOT_EQUAL_UINT64_INT64 = 233;         // $not_equal
  FN_OR = 46;                              // $or
  FN_SUBTRACT_DOUBLE = 115;                // $subtract
  FN_SUBTRACT_INT64 = 48;                  // $subtract
  FN_SUBTRACT_UINT64 = 117;                // $subtract
  FN_SUBTRACT_NUMERIC = 249;               // $subtract
  FN_SUBTRACT_BIGNUMERIC = 262;            // $subtract

  FN_UNARY_MINUS_INT32 = 83;        // $unary_minus
  FN_UNARY_MINUS_INT64 = 84;        // $unary_minus
  FN_UNARY_MINUS_FLOAT = 87;        // $unary_minus
  FN_UNARY_MINUS_DOUBLE = 88;       // $unary_minus
  FN_UNARY_MINUS_NUMERIC = 252;     // $unary_minus
  FN_UNARY_MINUS_BIGNUMERIC = 265;  // $unary_minus

  // Bitwise unary operators.
  FN_BITWISE_NOT_INT32 = 120;   // $bitwise_not
  FN_BITWISE_NOT_INT64 = 121;   // $bitwise_not
  FN_BITWISE_NOT_UINT32 = 122;  // $bitwise_not
  FN_BITWISE_NOT_UINT64 = 123;  // $bitwise_not
  FN_BITWISE_NOT_BYTES = 241;   // $bitwise_not
  // Bitwise binary operators.
  FN_BITWISE_OR_INT32 = 124;    // $bitwise_or
  FN_BITWISE_OR_INT64 = 125;    // $bitwise_or
  FN_BITWISE_OR_UINT32 = 126;   // $bitwise_or
  FN_BITWISE_OR_UINT64 = 127;   // $bitwise_or
  FN_BITWISE_OR_BYTES = 242;    // $bitwise_or
  FN_BITWISE_XOR_INT32 = 128;   // $bitwise_xor
  FN_BITWISE_XOR_INT64 = 129;   // $bitwise_xor
  FN_BITWISE_XOR_UINT32 = 130;  // $bitwise_xor
  FN_BITWISE_XOR_UINT64 = 131;  // $bitwise_xor
  FN_BITWISE_XOR_BYTES = 243;   // $bitwise_xor
  FN_BITWISE_AND_INT32 = 132;   // $bitwise_and
  FN_BITWISE_AND_INT64 = 133;   // $bitwise_and
  FN_BITWISE_AND_UINT32 = 134;  // $bitwise_and
  FN_BITWISE_AND_UINT64 = 135;  // $bitwise_and
  FN_BITWISE_AND_BYTES = 244;   // $bitwise_and
  // For all bitwise shift operators, the second argument has int64 type.
  // Expected behavior of bitwise shift operations:
  // * Shifting by a negative offset is an error.
  // * Shifting by >= 64 for uint64/int64 and >= 32 for int32/uint32 gives 0.
  // * Shifting right on signed values does not do sign extension.
  FN_BITWISE_LEFT_SHIFT_INT32 = 136;    // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_INT64 = 137;    // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_UINT32 = 138;   // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_UINT64 = 139;   // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_BYTES = 245;    // $bitwise_left_shift
  FN_BITWISE_RIGHT_SHIFT_INT32 = 140;   // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_INT64 = 141;   // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_UINT32 = 142;  // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_UINT64 = 143;  // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_BYTES = 246;   // $bitwise_right_shift

  // BIT_COUNT functions.
  FN_BIT_COUNT_INT32 = 144;   // bit_count(int32) -> int64
  FN_BIT_COUNT_INT64 = 145;   // bit_count(int64) -> int64
  FN_BIT_COUNT_UINT64 = 146;  // bit_count(uint64) -> int64
  FN_BIT_COUNT_BYTES = 247;   // bit_count(bytes) -> int64

  // TODO: Need to assign these proper ids since they have
  // standard function call syntax.
  FN_ARRAY_LENGTH = 220;           // array_length(array) -> int64
  FN_MAKE_ARRAY = 218;             // $make_array
  FN_ARRAY_AT_OFFSET = 234;        // $array_at_offset
  FN_ARRAY_AT_ORDINAL = 235;       // $array_at_ordinal
  FN_SAFE_ARRAY_AT_OFFSET = 239;   // $safe_array_at_offset
  FN_SAFE_ARRAY_AT_ORDINAL = 240;  // $safe_array_at_ordinal
  FN_ARRAY_CONCAT = 236;           // array_concat(repeated array) -> array
  FN_ARRAY_CONCAT_OP = 260;        // array_concat(array, array) -> array
  // array_to_string(array, string[, string]) -> string
  FN_ARRAY_TO_STRING = 237;
  // array_to_string(array, bytes[, bytes]) -> bytes
  FN_ARRAY_TO_BYTES = 238;

  FN_ERROR = 253;  // error(string) -> {unused result, coercible to any type}

  FN_COUNT_STAR = 57;  // $count_star

  // The following functions use standard function call syntax.
  // TODO: We may want to move all of these into another ID space
  // separating them from true built-in functions declared above.

  // String functions
  FN_CONCAT_STRING = 1000;          // concat(repeated string) -> string
  FN_CONCAT_BYTES = 1001;           // concat(repeated bytes) -> bytes
  FN_CONCAT_OP_STRING = 1063;       // concat(string, string) -> string
  FN_CONCAT_OP_BYTES = 1064;        // concat(bytes, bytes) -> bytes
  FN_STRPOS_STRING = 1002;          // strpos(string, string) -> int64
  FN_STRPOS_BYTES = 1003;           // strpos(bytes, bytes) -> int64
  FN_LOWER_STRING = 1006;           // lower(string) -> string
  FN_LOWER_BYTES = 1007;            // lower(bytes) -> bytes
  FN_UPPER_STRING = 1008;           // upper(string) -> string
  FN_UPPER_BYTES = 1009;            // upper(bytes) -> bytes
  FN_LENGTH_STRING = 1010;          // length(string) -> int64
  FN_LENGTH_BYTES = 1011;           // length(bytes) -> int64
  FN_STARTS_WITH_STRING = 1012;     // starts_with(string, string) -> string
  FN_STARTS_WITH_BYTES = 1013;      // starts_with(bytes, bytes) -> bytes
  FN_ENDS_WITH_STRING = 1014;       // ends_with(string, string) -> string
  FN_ENDS_WITH_BYTES = 1015;        // ends_with(bytes, bytes) -> bytes
  FN_SUBSTR_STRING = 1016;          // substr(string, int64[, int64]) -> string
  FN_SUBSTR_BYTES = 1017;           // substr(bytes, int64[, int64]) -> bytes
  FN_TRIM_STRING = 1018;            // trim(string[, string]) -> string
  FN_TRIM_BYTES = 1019;             // trim(bytes, bytes) -> bytes
  FN_LTRIM_STRING = 1020;           // ltrim(string[, string]) -> string
  FN_LTRIM_BYTES = 1021;            // ltrim(bytes, bytes) -> bytes
  FN_RTRIM_STRING = 1022;           // rtrim(string[, string]) -> string
  FN_RTRIM_BYTES = 1023;            // rtrim(bytes, bytes) -> bytes
  FN_REPLACE_STRING = 1024;         // replace(string, string, string) -> string
  FN_REPLACE_BYTES = 1025;          // replace(bytes, bytes, bytes) -> bytes
  FN_REGEXP_MATCH_STRING = 1026;    // regexp_match(string, string) -> bool
  FN_REGEXP_MATCH_BYTES = 1027;     // regexp_match(bytes, bytes) -> bool
  FN_REGEXP_EXTRACT_STRING = 1028;  // regexp_extract(string, string) -> string
  FN_REGEXP_EXTRACT_BYTES = 1029;   // regexp_extract(bytes, bytes) -> bytes
  FN_REGEXP_REPLACE_STRING = 1030;
  // regexp_replace(string, string, string) -> string
  FN_REGEXP_REPLACE_BYTES = 1031;
  // regexp_replace(bytes, bytes, bytes) -> bytes
  FN_REGEXP_EXTRACT_ALL_STRING = 1032;
  // regexp_extract_all(string, string) -> array of string
  FN_REGEXP_EXTRACT_ALL_BYTES = 1033;
  // regexp_extract_all(bytes, bytes) -> array of bytes
  FN_BYTE_LENGTH_STRING = 1034;  // byte_length(string) -> int64
  FN_BYTE_LENGTH_BYTES = 1035;   // byte_length(bytes) -> int64
                                 // semantically identical to FN_LENGTH_BYTES
  FN_CHAR_LENGTH_STRING = 1036;  // char_length(string) -> int64
                                 // semantically identical to FN_LENGTH_STRING
  FN_SPLIT_STRING = 1038;            // split(string, string) -> array of string
  FN_SPLIT_BYTES = 1039;             // split(bytes, bytes) -> array of bytes
  FN_REGEXP_CONTAINS_STRING = 1040;  // regexp_contains(string, string) -> bool
  FN_REGEXP_CONTAINS_BYTES = 1041;   // regexp_contains(bytes, bytes) -> bool
  // Converts bytes to string by replacing invalid UTF-8 characters with
  // replacement char U+FFFD.
  FN_SAFE_CONVERT_BYTES_TO_STRING = 1042;
  // Unicode normalization and casefolding functions.
  FN_NORMALIZE_STRING = 1043;  // normalize(string [, mode]) -> string
  // normalize_and_casefold(string [, mode]) -> string
  FN_NORMALIZE_AND_CASEFOLD_STRING = 1044;
  FN_TO_BASE64 = 1045;    // to_base64(bytes) -> string
  FN_FROM_BASE64 = 1046;  // from_base64(string) -> bytes
  FN_TO_HEX = 1059;       // to_hex(bytes) -> string
  FN_FROM_HEX = 1060;     // from_hex(string) -> bytes
  FN_TO_BASE32 = 1061;    // to_base32(bytes) -> string
  FN_FROM_BASE32 = 1062;  // from_base32(string) -> bytes
  // to_code_points(string) -> array<int64>
  FN_TO_CODE_POINTS_STRING = 1047;
  // to_code_points(bytes) -> array<int64>
  FN_TO_CODE_POINTS_BYTES = 1048;
  // code_points_to_string(array<int64>) -> string
  FN_CODE_POINTS_TO_STRING = 1049;
  // code_points_to_bytes(array<int64>) -> bytes
  FN_CODE_POINTS_TO_BYTES = 1050;
  FN_LPAD_BYTES = 1051;      // lpad(bytes, int64[, bytes]) -> bytes
  FN_LPAD_STRING = 1052;     // lpad(string, int64[, string]) -> string
  FN_RPAD_BYTES = 1053;      // rpad(bytes, int64[, bytes]) -> bytes
  FN_RPAD_STRING = 1054;     // rpad(string, int64[, string]) -> string
  FN_LEFT_STRING = 1065;     // left(string, int64) -> string
  FN_LEFT_BYTES = 1066;      // left(bytes, int64) -> bytes
  FN_RIGHT_STRING = 1067;    // right(string, int64) -> string
  FN_RIGHT_BYTES = 1068;     // right(bytes, int64) -> bytes
  FN_REPEAT_BYTES = 1055;    // repeat(bytes, int64) -> bytes
  FN_REPEAT_STRING = 1056;   // repeat(string, int64) -> string
  FN_REVERSE_STRING = 1057;  // reverse(string) -> string
  FN_REVERSE_BYTES = 1058;   // reverse(bytes) -> bytes

  // Control flow functions
  FN_IF = 1100;  // if
  // Coalesce is used to express the output join column in FULL JOIN.
  FN_COALESCE = 1101;  // coalesce
  FN_IFNULL = 1102;    // ifnull
  FN_NULLIF = 1103;    // nullif

  // Time functions
  FN_CURRENT_DATE = 1200;       // current_date
  FN_CURRENT_DATETIME = 1804;   // current_datetime
  FN_CURRENT_TIME = 1805;       // current_time
  FN_CURRENT_TIMESTAMP = 1260;  // current_timestamp
  FN_DATE_ADD_DATE = 1205;  // date_add
  FN_DATETIME_ADD = 1812;   // datetime_add
  FN_TIME_ADD = 1813;       // time_add
  FN_TIMESTAMP_ADD = 1261;  // timestamp_add
  FN_DATE_DIFF_DATE = 1210;  // date_diff
  FN_DATETIME_DIFF = 1816;   // datetime_diff
  FN_TIME_DIFF = 1817;       // time_diff
  FN_TIMESTAMP_DIFF = 1262;  // timestamp_diff
  FN_DATE_SUB_DATE = 1215;  // date_sub
  FN_DATETIME_SUB = 1814;   // datetime_sub
  FN_TIME_SUB = 1815;       // time_sub
  FN_TIMESTAMP_SUB = 1263;  // timestamp_sub
  FN_DATE_TRUNC_DATE = 1220;  // date_trunc
  FN_DATETIME_TRUNC = 1818;   // datetime_trunc
  FN_TIME_TRUNC = 1819;       // time_trunc
  FN_TIMESTAMP_TRUNC = 1264;  // timestamp_trunc

  FN_DATE_FROM_UNIX_DATE = 1225;  // date_from_unix_date
  FN_TIMESTAMP_FROM_INT64_SECONDS = 1289;  // timestamp_seconds
  FN_TIMESTAMP_FROM_INT64_MILLIS = 1290;   // timestamp_millis
  FN_TIMESTAMP_FROM_INT64_MICROS = 1291;   // timestamp_micros
  FN_TIMESTAMP_FROM_UNIX_SECONDS_INT64 = 1827;  // timestamp_from_unix_seconds
  FN_TIMESTAMP_FROM_UNIX_SECONDS_TIMESTAMP =
      1828;                                    // timestamp_from_unix_seconds
  FN_TIMESTAMP_FROM_UNIX_MILLIS_INT64 = 1829;  // timestamp_from_unix_millis
  FN_TIMESTAMP_FROM_UNIX_MILLIS_TIMESTAMP = 1830;  // timestamp_from_unix_millis
  FN_TIMESTAMP_FROM_UNIX_MICROS_INT64 = 1831;      // timestamp_from_unix_micros
  FN_TIMESTAMP_FROM_UNIX_MICROS_TIMESTAMP = 1832;  // timestamp_from_unix_micros
  FN_UNIX_DATE = 1230;                             // unix_date
  FN_UNIX_SECONDS_FROM_TIMESTAMP = 1268;
  FN_UNIX_MILLIS_FROM_TIMESTAMP = 1269;
  FN_UNIX_MICROS_FROM_TIMESTAMP = 1270;
  FN_DATE_FROM_TIMESTAMP = 1271;  // date
  FN_DATE_FROM_DATETIME = 1826;   // date
  FN_DATE_FROM_YEAR_MONTH_DAY = 1297;  // date
  FN_TIMESTAMP_FROM_STRING = 1272;     // timestamp
  FN_TIMESTAMP_FROM_DATE = 1273;       // timestamp
  FN_TIMESTAMP_FROM_DATETIME = 1801;   // timestamp
  FN_TIME_FROM_HOUR_MINUTE_SECOND = 1298;                     // time
  FN_TIME_FROM_TIMESTAMP = 1802;                              // time
  FN_TIME_FROM_DATETIME = 1825;                               // time
  FN_DATETIME_FROM_DATE_AND_TIME = 1299;                      // datetime
  FN_DATETIME_FROM_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND = 1800;  // datetime
  FN_DATETIME_FROM_TIMESTAMP = 1803;                          // datetime
  FN_DATETIME_FROM_DATE = 1824;                               // datetime

  FN_STRING_FROM_TIMESTAMP = 1274;  // string

  // Signatures for extracting date parts, taking a date/timestamp
  // and the target date part as arguments.
  FN_EXTRACT_FROM_DATE = 1251;       // $extract
  FN_EXTRACT_FROM_DATETIME = 1806;   // $extract
  FN_EXTRACT_FROM_TIME = 1807;       // $extract
  FN_EXTRACT_FROM_TIMESTAMP = 1275;  // $extract

  // Signatures specific to extracting the DATE date part from a DATETIME or a
  // TIMESTAMP.
  FN_EXTRACT_DATE_FROM_DATETIME = 1808;   // $extract_date
  FN_EXTRACT_DATE_FROM_TIMESTAMP = 1276;  // $extract_date

  // Signatures specific to extracting the TIME date part from a DATETIME or a
  // TIMESTAMP.
  FN_EXTRACT_TIME_FROM_DATETIME = 1809;   // $extract_time
  FN_EXTRACT_TIME_FROM_TIMESTAMP = 1810;  // $extract_time

  // Signature specific to extracting the DATETIME date part from a TIMESTAMP.
  FN_EXTRACT_DATETIME_FROM_TIMESTAMP = 1811;  // $extract_datetime

  FN_FORMAT_DATE = 1293;       // format_date
  FN_FORMAT_DATETIME = 1820;   // format_datetime
  FN_FORMAT_TIME = 1821;       // format_time
  FN_FORMAT_TIMESTAMP = 1294;  // format_timestamp
  FN_PARSE_DATE = 1295;        // parse_date
  FN_PARSE_DATETIME = 1822;    // parse_datetime
  FN_PARSE_TIME = 1823;        // parse_time
  FN_PARSE_TIMESTAMP = 1296;   // parse_timestamp

  // Math functions
  FN_ABS_INT32 = 1300;        // abs
  FN_ABS_INT64 = 1301;        // abs
  FN_ABS_UINT32 = 1346;       // abs
  FN_ABS_UINT64 = 1347;       // abs
  FN_ABS_FLOAT = 1302;        // abs
  FN_ABS_DOUBLE = 1303;       // abs
  FN_ABS_NUMERIC = 1359;      // abs
  FN_ABS_BIGNUMERIC = 1395;   // abs
  FN_SIGN_INT32 = 1341;       // sign
  FN_SIGN_INT64 = 1342;       // sign
  FN_SIGN_UINT32 = 1356;      // sign
  FN_SIGN_UINT64 = 1357;      // sign
  FN_SIGN_FLOAT = 1343;       // sign
  FN_SIGN_DOUBLE = 1344;      // sign
  FN_SIGN_NUMERIC = 1360;     // sign
  FN_SIGN_BIGNUMERIC = 1396;  // sign

  FN_ROUND_DOUBLE = 1305;               // round(double) -> double
  FN_ROUND_FLOAT = 1306;                // round(float) -> float
  FN_ROUND_NUMERIC = 1363;              // round(numeric) -> numeric
  FN_ROUND_BIGNUMERIC = 1397;           // round(bignumeric) -> bignumeric
  FN_ROUND_WITH_DIGITS_DOUBLE = 1307;   // round(double, int64) -> double
  FN_ROUND_WITH_DIGITS_FLOAT = 1308;    // round(float, int64) -> float
  FN_ROUND_WITH_DIGITS_NUMERIC = 1364;  // round(numeric, int64) -> numeric
  FN_ROUND_WITH_DIGITS_BIGNUMERIC =
      1398;                            // round(bignumeric, int64) -> bignumeric
  FN_TRUNC_DOUBLE = 1309;              // trunc(double) -> double
  FN_TRUNC_FLOAT = 1310;               // trunc(float) -> float
  FN_TRUNC_NUMERIC = 1365;             // trunc(numeric) -> numeric
  FN_TRUNC_BIGNUMERIC = 1399;          // trunc(bignumeric) -> bignumeric
  FN_TRUNC_WITH_DIGITS_DOUBLE = 1311;  // trunc(double, int64) -> double
  FN_TRUNC_WITH_DIGITS_FLOAT = 1312;   // trunc(float, int64) -> float
  FN_TRUNC_WITH_DIGITS_NUMERIC = 1366;  // trunc(numeric, int64) -> numeric
  FN_TRUNC_WITH_DIGITS_BIGNUMERIC =
      2300;                    // trunc(bignumeric, int64) -> bignumeric
  FN_CEIL_DOUBLE = 1313;       // ceil(double) -> double
  FN_CEIL_FLOAT = 1314;        // ceil(float) -> float
  FN_CEIL_NUMERIC = 1368;      // ceil(numeric) -> numeric
  FN_CEIL_BIGNUMERIC = 1393;   // ceil(bignumeric) -> bignumeric
  FN_FLOOR_DOUBLE = 1315;      // floor(double) -> double
  FN_FLOOR_FLOAT = 1316;       // floor(float) -> float
  FN_FLOOR_NUMERIC = 1369;     // floor(numeric) -> numeric
  FN_FLOOR_BIGNUMERIC = 1394;  // floor(bignumeric) -> bignumeric

  FN_MOD_INT64 = 1349;       // mod(int64, int64) -> int64
  FN_MOD_UINT64 = 1351;      // mod(uint64, uint64) -> uint64
  FN_MOD_NUMERIC = 1367;     // mod(numeric, numeric) -> numeric
  FN_MOD_BIGNUMERIC = 2301;  // mod(bignumeric, bignumeric) -> bignumeric
  FN_DIV_INT64 = 1353;       // div(int64, int64) -> int64
  FN_DIV_UINT64 = 1355;      // div(uint64, uint64) -> uint64
  FN_DIV_NUMERIC = 1362;     // div(numeric, numeric) -> numeric
  FN_DIV_BIGNUMERIC = 2302;  // div(bignumeric, bignumeric) -> bignumeric

  FN_IS_INF = 1317;                       // is_inf
  FN_IS_NAN = 1318;                       // is_nan
  FN_IEEE_DIVIDE_DOUBLE = 1319;           // ieee_divide
  FN_IEEE_DIVIDE_FLOAT = 1320;            // ieee_divide
  FN_SAFE_DIVIDE_DOUBLE = 1358;           // safe_divide
  FN_SAFE_DIVIDE_NUMERIC = 1361;          // safe_divide
  FN_SAFE_DIVIDE_BIGNUMERIC = 1388;       // safe_divide
  FN_SAFE_ADD_INT64 = 1371;               // safe_add
  FN_SAFE_ADD_UINT64 = 1372;              // safe_add
  FN_SAFE_ADD_DOUBLE = 1373;              // safe_add
  FN_SAFE_ADD_NUMERIC = 1374;             // safe_add
  FN_SAFE_ADD_BIGNUMERIC = 1389;          // safe_add
  FN_SAFE_SUBTRACT_INT64 = 1375;          // safe_subtract
  FN_SAFE_SUBTRACT_UINT64 = 1376;         // safe_subtract
  FN_SAFE_SUBTRACT_DOUBLE = 1377;         // safe_subtract
  FN_SAFE_SUBTRACT_NUMERIC = 1378;        // safe_subtract
  FN_SAFE_SUBTRACT_BIGNUMERIC = 1390;     // safe_subtract
  FN_SAFE_MULTIPLY_INT64 = 1379;          // safe_multiply
  FN_SAFE_MULTIPLY_UINT64 = 1380;         // safe_multiply
  FN_SAFE_MULTIPLY_DOUBLE = 1381;         // safe_multiply
  FN_SAFE_MULTIPLY_NUMERIC = 1382;        // safe_multiply
  FN_SAFE_MULTIPLY_BIGNUMERIC = 1391;     // safe_multiply
  FN_SAFE_UNARY_MINUS_INT32 = 1383;       // safe_negate
  FN_SAFE_UNARY_MINUS_INT64 = 1384;       // safe_negate
  FN_SAFE_UNARY_MINUS_FLOAT = 1385;       // safe_negate
  FN_SAFE_UNARY_MINUS_DOUBLE = 1386;      // safe_negate
  FN_SAFE_UNARY_MINUS_NUMERIC = 1387;     // safe_negate
  FN_SAFE_UNARY_MINUS_BIGNUMERIC = 1392;  // safe_negate

  FN_GREATEST = 1321;  // greatest
  FN_LEAST = 1322;     // least

  FN_SQRT_DOUBLE = 1323;               // sqrt
  FN_POW_DOUBLE = 1324;                // pow
  FN_POW_NUMERIC = 1370;               // pow(numeric, numeric) -> numeric
  FN_EXP_DOUBLE = 1325;                // exp
  FN_NATURAL_LOGARITHM_DOUBLE = 1326;  // ln and log
  FN_DECIMAL_LOGARITHM_DOUBLE = 1345;  // log10
  FN_LOGARITHM_DOUBLE = 1327;          // log

  FN_COS_DOUBLE = 1328;    // cos
  FN_COSH_DOUBLE = 1329;   // cosh
  FN_ACOS_DOUBLE = 1330;   // acos
  FN_ACOSH_DOUBLE = 1331;  // acosh
  FN_SIN_DOUBLE = 1332;    // sin
  FN_SINH_DOUBLE = 1333;   // sinh
  FN_ASIN_DOUBLE = 1334;   // asin
  FN_ASINH_DOUBLE = 1335;  // asinh
  FN_TAN_DOUBLE = 1336;    // tan
  FN_TANH_DOUBLE = 1337;   // tanh
  FN_ATAN_DOUBLE = 1338;   // atan
  FN_ATANH_DOUBLE = 1339;  // atanh
  FN_ATAN2_DOUBLE = 1340;  // atan2

  // Aggregate functions.
  // TODO: Add missing type signatures.
  FN_ANY_VALUE = 1400;                // any_value
  FN_ARRAY_AGG = 1401;                // array_agg
  FN_ARRAY_CONCAT_AGG = 1442;         // array_concat_agg
  FN_AVG_INT64 = 1402;                // avg
  FN_AVG_UINT64 = 1403;               // avg
  FN_AVG_DOUBLE = 1404;               // avg
  FN_AVG_NUMERIC = 1468;              // avg
  FN_AVG_BIGNUMERIC = 1479;           // avg
  FN_COUNT = 1405;                    // count
  FN_MAX = 1406;                      // max
  FN_MIN = 1407;                      // min
  FN_STRING_AGG_STRING = 1408;        // string_agg(s)
  FN_STRING_AGG_DELIM_STRING = 1409;  // string_agg(s, delim_s)
  FN_STRING_AGG_BYTES = 1413;         // string_agg(b)
  FN_STRING_AGG_DELIM_BYTES = 1414;   // string_agg(b, delim_b)
  FN_SUM_INT64 = 1410;                // sum
  FN_SUM_UINT64 = 1411;               // sum
  FN_SUM_DOUBLE = 1412;               // sum
  FN_SUM_NUMERIC = 1467;              // sum
  FN_SUM_BIGNUMERIC = 1478;           // sum
  FN_BIT_AND_INT32 = 1415;            // bit_and
  FN_BIT_AND_INT64 = 1416;            // bit_and
  FN_BIT_AND_UINT32 = 1417;           // bit_and
  FN_BIT_AND_UINT64 = 1418;           // bit_and
  FN_BIT_OR_INT32 = 1419;             // bit_or
  FN_BIT_OR_INT64 = 1420;             // bit_or
  FN_BIT_OR_UINT32 = 1421;            // bit_or
  FN_BIT_OR_UINT64 = 1422;            // bit_or
  FN_BIT_XOR_INT32 = 1423;            // bit_xor
  FN_BIT_XOR_INT64 = 1424;            // bit_xor
  FN_BIT_XOR_UINT32 = 1425;           // bit_xor
  FN_BIT_XOR_UINT64 = 1426;           // bit_xor
  FN_LOGICAL_AND = 1427;              // logical_and
  FN_LOGICAL_OR = 1428;               // logical_or
  // Approximate aggregate functions.
  FN_APPROX_COUNT_DISTINCT = 1429;      // approx_count_distinct
  FN_APPROX_QUANTILES = 1430;           // approx_quantiles
  FN_APPROX_TOP_COUNT = 1431;           // approx_top_count
  FN_APPROX_TOP_SUM_INT64 = 1432;       // approx_top_sum
  FN_APPROX_TOP_SUM_UINT64 = 1433;      // approx_top_sum
  FN_APPROX_TOP_SUM_DOUBLE = 1434;      // approx_top_sum
  FN_APPROX_TOP_SUM_NUMERIC = 1469;     // approx_top_sum
  FN_APPROX_TOP_SUM_BIGNUMERIC = 1480;  // approx_top_sum

  // Approximate count functions that expose the intermediate sketch.
  // These are all found in the "hll_count.*" namespace.
  //
  FN_HLL_COUNT_MERGE = 1444;          // hll_count.merge(bytes)
  FN_HLL_COUNT_EXTRACT = 1445;        // hll_count.extract(bytes), scalar
  FN_HLL_COUNT_INIT_INT64 = 1446;     // hll_count.init(int64)
  FN_HLL_COUNT_INIT_UINT64 = 1447;    // hll_count.init(uint64)
  FN_HLL_COUNT_INIT_NUMERIC = 1470;   // hll_count.init(numeric)
  FN_HLL_COUNT_INIT_STRING = 1448;    // hll_count.init(string)
  FN_HLL_COUNT_INIT_BYTES = 1449;     // hll_count.init(bytes)
  FN_HLL_COUNT_MERGE_PARTIAL = 1450;  // hll_count.merge_partial(bytes)

  // Statistical aggregate functions.
  FN_CORR = 1435;                 // corr
  FN_CORR_NUMERIC = 1471;         // corr
  FN_COVAR_POP = 1436;            // covar_pop
  FN_COVAR_POP_NUMERIC = 1472;    // covar_pop
  FN_COVAR_SAMP = 1437;           // covar_samp
  FN_COVAR_SAMP_NUMERIC = 1473;   // covar_samp
  FN_STDDEV_POP = 1438;           // stddev_pop
  FN_STDDEV_POP_NUMERIC = 1474;   // stddev_pop
  FN_STDDEV_SAMP = 1439;          // stddev_samp
  FN_STDDEV_SAMP_NUMERIC = 1475;  // stddev_samp
  FN_VAR_POP = 1440;              // var_pop
  FN_VAR_POP_NUMERIC = 1476;      // var_pop
  FN_VAR_SAMP = 1441;             // var_samp
  FN_VAR_SAMP_NUMERIC = 1477;     // var_samp

  FN_COUNTIF = 1443;  // countif

  // Approximate quantiles functions that produce or consume intermediate
  // sketches. All found in the "kll_quantiles.*" namespace.
  //
  FN_KLL_QUANTILES_INIT_INT64 = 1451;
  FN_KLL_QUANTILES_INIT_UINT64 = 1452;
  FN_KLL_QUANTILES_INIT_DOUBLE = 1453;
  FN_KLL_QUANTILES_MERGE_PARTIAL = 1454;
  FN_KLL_QUANTILES_MERGE_INT64 = 1455;
  FN_KLL_QUANTILES_MERGE_UINT64 = 1456;
  FN_KLL_QUANTILES_MERGE_DOUBLE = 1457;
  FN_KLL_QUANTILES_EXTRACT_INT64 = 1458;   // scalar
  FN_KLL_QUANTILES_EXTRACT_UINT64 = 1459;  // scalar
  FN_KLL_QUANTILES_EXTRACT_DOUBLE = 1460;  // scalar
  FN_KLL_QUANTILES_MERGE_POINT_INT64 = 1461;
  FN_KLL_QUANTILES_MERGE_POINT_UINT64 = 1462;
  FN_KLL_QUANTILES_MERGE_POINT_DOUBLE = 1463;
  FN_KLL_QUANTILES_EXTRACT_POINT_INT64 = 1464;   // scalar
  FN_KLL_QUANTILES_EXTRACT_POINT_UINT64 = 1465;  // scalar
  FN_KLL_QUANTILES_EXTRACT_POINT_DOUBLE = 1466;  // scalar

  // Analytic functions.
  FN_DENSE_RANK = 1500;       // dense_rank
  FN_RANK = 1501;             // rank
  FN_ROW_NUMBER = 1502;       // row_number
  FN_PERCENT_RANK = 1503;     // percent_rank
  FN_CUME_DIST = 1504;        // cume_dist
  FN_NTILE = 1505;            // ntile
  FN_LEAD = 1506;             // lead
  FN_LAG = 1507;              // lag
  FN_FIRST_VALUE = 1508;      // first_value
  FN_LAST_VALUE = 1509;       // last_value
  FN_NTH_VALUE = 1510;        // nth_value
  FN_PERCENTILE_CONT = 1511;  // percentile_cont
  FN_PERCENTILE_DISC = 1512;  // percentile_disc

  //
  // Misc functions.

  FN_BIT_CAST_INT32_TO_INT32 = 1604;    // bit_cast_to_int32(int32)
  FN_BIT_CAST_UINT32_TO_INT32 = 1605;   // bit_cast_to_int32(uint32)
  FN_BIT_CAST_INT64_TO_INT64 = 1606;    // bit_cast_to_int64(int64)
  FN_BIT_CAST_UINT64_TO_INT64 = 1607;   // bit_cast_to_int64(uint64)
  FN_BIT_CAST_UINT32_TO_UINT32 = 1608;  // bit_cast_to_uint32(uint32)
  FN_BIT_CAST_INT32_TO_UINT32 = 1609;   // bit_cast_to_uint32(int32)
  FN_BIT_CAST_UINT64_TO_UINT64 = 1610;  // bit_cast_to_uint64(uint64)
  FN_BIT_CAST_INT64_TO_UINT64 = 1611;   // bit_cast_to_uint64(int64)

  FN_SESSION_USER = 1612;  // session_user

  FN_GENERATE_ARRAY_INT64 = 1613;       // generate_array(int64)
  FN_GENERATE_ARRAY_UINT64 = 1614;      // generate_array(uint64)
  FN_GENERATE_ARRAY_NUMERIC = 1625;     // generate_array(numeric)
  FN_GENERATE_ARRAY_BIGNUMERIC = 1683;  // generate_array(bignumeric)
  FN_GENERATE_ARRAY_DOUBLE = 1615;      // generate_array(double)
  FN_GENERATE_DATE_ARRAY = 1616;        // generate_date_array(date)
  FN_GENERATE_TIMESTAMP_ARRAY = 1617;   // generate_timestamp_array(timestamp)

  FN_ARRAY_REVERSE = 1621;  // array_reverse(array) -> array

  FN_RANGE_BUCKET = 1680;  //  range_bucket(T, array<T>) -> int64

  FN_RAND = 1618;           // rand() -> double
  FN_GENERATE_UUID = 1679;  // generate_uuid() -> string

  FN_JSON_EXTRACT = 1619;         // json_extract(string, string)
  FN_JSON_EXTRACT_SCALAR = 1620;  // json_extract_scalar(string, string)
  FN_JSON_EXTRACT_ARRAY =
      1681;  // json_extract_array(string[, string]) -> array

  FN_TO_JSON_STRING = 1622;  // to_json_string(any[, bool]) -> string
  FN_JSON_QUERY = 1623;      // json_query(string, string)
  FN_JSON_VALUE = 1624;      // json_value(string, string)
  FN_FROM_PROTO_TIMESTAMP =
      1626;  // from_proto(google.protobuf.Timestamp) -> timestamp
  FN_FROM_PROTO_DATE = 1627;  // from_proto(google.type.Date) -> date
  FN_FROM_PROTO_TIME_OF_DAY =
      1628;  // from_proto(google.type.TimeOfDay) -> time
  FN_FROM_PROTO_DOUBLE =
      1630;  // from_proto(google.protobuf.DoubleValue) -> double
  FN_FROM_PROTO_FLOAT =
      1631;  // from_proto(google.protobuf.FloatValue) -> float
  FN_FROM_PROTO_INT64 =
      1632;  // from_proto(google.protobuf.Int64Value) -> int64
  FN_FROM_PROTO_UINT64 =
      1633;  // from_proto(google.protobuf.UInt64Value) -> uint64
  FN_FROM_PROTO_INT32 =
      1634;  // from_proto(google.protobuf.Int32Value) -> int32
  FN_FROM_PROTO_UINT32 =
      1635;  // from_proto(google.protobuf.UInt32Value) -> uint32
  FN_FROM_PROTO_BOOL = 1636;  // from_proto(google.protobuf.BoolValue) -> bool
  FN_FROM_PROTO_BYTES =
      1637;  // from_proto(google.protobuf.BytesValue) -> bytes
  FN_FROM_PROTO_STRING =
      1638;  // from_proto(google.protobuf.StringValue) -> string

  // The idempotent signatures of from_proto just return the input value
  FN_FROM_PROTO_IDEMPOTENT_TIMESTAMP =
      1639;                              // from_proto(timestamp) -> timestamp
  FN_FROM_PROTO_IDEMPOTENT_DATE = 1640;  // from_proto(date) -> date
  FN_FROM_PROTO_IDEMPOTENT_TIME = 1641;  // from_proto(time) -> time
  FN_FROM_PROTO_IDEMPOTENT_DOUBLE = 1643;  // from_proto(double) -> double
  FN_FROM_PROTO_IDEMPOTENT_FLOAT = 1644;   // from_proto(float) -> float
  FN_FROM_PROTO_IDEMPOTENT_INT64 = 1645;   // from_proto(int64) -> int64
  FN_FROM_PROTO_IDEMPOTENT_UINT64 = 1646;  // from_proto(uint64) -> uint64
  FN_FROM_PROTO_IDEMPOTENT_INT32 = 1647;   // from_proto(int32) -> int32
  FN_FROM_PROTO_IDEMPOTENT_UINT32 = 1648;  // from_proto(uint32) -> uint32
  FN_FROM_PROTO_IDEMPOTENT_BOOL = 1649;    // from_proto(bool) -> bool
  FN_FROM_PROTO_IDEMPOTENT_BYTES = 1650;   // from_proto(bytes) -> bytes
  FN_FROM_PROTO_IDEMPOTENT_STRING = 1651;  // from_proto(string) -> string

  FN_TO_PROTO_TIMESTAMP =
      1652;                 // to_proto(timestamp) -> google.protobuf.Timestamp
  FN_TO_PROTO_DATE = 1653;  // to_proto(date) -> google.type.Date
  FN_TO_PROTO_TIME = 1654;  // to_proto(time) -> google.type.TimeOfDay
  FN_TO_PROTO_DOUBLE = 1656;  // to_proto(double) -> google.protobuf.DoubleValue
  FN_TO_PROTO_FLOAT = 1657;   // to_proto(float) -> google.protobuf.FloatValue
  FN_TO_PROTO_INT64 = 1658;   // to_proto(int64) -> google.protobuf.Int64Value
  FN_TO_PROTO_UINT64 = 1659;  // to_proto(uint64) -> google.protobuf.UInt64Value
  FN_TO_PROTO_INT32 = 1660;   // to_proto(int32) -> google.protobuf.Int32Value
  FN_TO_PROTO_UINT32 = 1661;  // to_proto(uint32) -> google.protobuf.UInt32Value
  FN_TO_PROTO_BOOL = 1662;    // to_proto(bool) -> google.protobuf.BoolValue
  FN_TO_PROTO_BYTES = 1663;   // to_proto(bytes) -> google.protobuf.BytesValue
  FN_TO_PROTO_STRING = 1664;  // to_proto(string) -> google.protobuf.StringValue

  // The idempotent signatures of to_proto just return the input value
  FN_TO_PROTO_IDEMPOTENT_TIMESTAMP =
      1665;  // to_proto(google.protobuf.Timestamp) -> google.protobuf.Timestamp
  FN_TO_PROTO_IDEMPOTENT_DATE =
      1666;  // to_proto(google.type.Date) -> google.type.Date
  FN_TO_PROTO_IDEMPOTENT_TIME_OF_DAY =
      1667;  // to_proto(google.type.TimeOfDay) -> google.type.TimeOfDay
  FN_TO_PROTO_IDEMPOTENT_DOUBLE =
      1669;                             // to_proto(google.protobuf.DoubleValue)
                                        // -> google.protobuf.DoubleValue
  FN_TO_PROTO_IDEMPOTENT_FLOAT = 1670;  // to_proto(google.protobuf.FloatValue)
                                        // -> google.protobuf.FloatValue
  FN_TO_PROTO_IDEMPOTENT_INT64 = 1671;  // to_proto(google.protobuf.Int64Value)
                                        // -> google.protobuf.Int64Value
  FN_TO_PROTO_IDEMPOTENT_UINT64 =
      1672;                             // to_proto(google.protobuf.UInt64Value)
                                        // -> google.protobuf.UInt64Value
  FN_TO_PROTO_IDEMPOTENT_INT32 = 1673;  // to_proto(google.protobuf.Int32Value)
                                        // -> google.protobuf.Int32Value
  FN_TO_PROTO_IDEMPOTENT_UINT32 =
      1674;  // to_proto(google.protobuf.UInt32Value)
             // -> google.protobuf.UInt32Value
  FN_TO_PROTO_IDEMPOTENT_BOOL =
      1675;  // to_proto(google.protobuf.BoolValue) -> google.protobuf.BoolValue
  FN_TO_PROTO_IDEMPOTENT_BYTES = 1676;  // to_proto(google.protobuf.BytesValue)
                                        // -> google.protobuf.BytesValue
  FN_TO_PROTO_IDEMPOTENT_STRING =
      1677;  // to_proto(google.protobuf.StringValue)
             // -> google.protobuf.StringValue

  FN_PROTO_DEFAULT_IF_NULL =
      1678;  // proto_default_if_null(<non-message optional field access>)

  FN_ENUM_VALUE_DESCRIPTOR_PROTO =
      1682;  // enum_value_descriptor_proto(<enum expression>) ->
             // google.protobuf.EnumValueDescriptorProto

  // Net functions. These are all found in the "net.*" namespace.
  FN_NET_FORMAT_IP = 1700;
  FN_NET_PARSE_IP = 1701;
  FN_NET_FORMAT_PACKED_IP = 1702;
  FN_NET_PARSE_PACKED_IP = 1703;
  FN_NET_IP_IN_NET = 1704;
  FN_NET_MAKE_NET = 1705;
  FN_NET_HOST = 1706;                 // net.host(string)
  FN_NET_REG_DOMAIN = 1707;           // net.reg_domain(string)
  FN_NET_PUBLIC_SUFFIX = 1708;        // net.public_suffix(string)
  FN_NET_IP_FROM_STRING = 1709;       // net.ip_from_string(string)
  FN_NET_SAFE_IP_FROM_STRING = 1710;  // net.safe_ip_from_string(string)
  FN_NET_IP_TO_STRING = 1711;         // net.ip_to_string(bytes)
  FN_NET_IP_NET_MASK = 1712;          // net.ip_net_mask(int64, int64)
  FN_NET_IP_TRUNC = 1713;             // net.ip_net_mask(bytes, int64)
  FN_NET_IPV4_FROM_INT64 = 1714;      // net.ipv4_from_int64(int64)
  FN_NET_IPV4_TO_INT64 = 1715;        // net.ipv4_to_int64(bytes)

  // Hashing functions.
  FN_MD5_BYTES = 1900;      // md5(bytes)
  FN_MD5_STRING = 1901;     // md5(string)
  FN_SHA1_BYTES = 1902;     // sha1(bytes)
  FN_SHA1_STRING = 1903;    // sha1(string)
  FN_SHA256_BYTES = 1904;   // sha256(bytes)
  FN_SHA256_STRING = 1905;  // sha256(string)
  FN_SHA512_BYTES = 1906;   // sha512(bytes)
  FN_SHA512_STRING = 1907;  // sha512(string)

  // Fingerprinting functions
  FN_FARM_FINGERPRINT_BYTES = 1908;   // farm_fingerprint(bytes) -> int64
  FN_FARM_FINGERPRINT_STRING = 1909;  // farm_fingerprint(string) -> int64

  // Keyset management, encryption, and decryption functions
  // ((broken link)). Requires that FEATURE_ENCRYPTION is enabled.
  FN_KEYS_NEW_KEYSET = 1910;  // keys.new_keyset(string)
  // keys.add_key_from_raw_bytes(bytes, string, bytes)
  FN_KEYS_ADD_KEY_FROM_RAW_BYTES = 1911;
  FN_KEYS_ROTATE_KEYSET = 1912;     // keys.rotate_keyset(bytes, string)
  FN_KEYS_KEYSET_LENGTH = 1913;     // keys.keyset_length(bytes)
  FN_KEYS_KEYSET_TO_JSON = 1914;    // keys.keyset_to_json(bytes)
  FN_KEYS_KEYSET_FROM_JSON = 1915;  // keys.keyset_from_json(string)
  FN_AEAD_ENCRYPT_STRING = 1916;    // aead.encrypt(bytes, string, string)
  FN_AEAD_ENCRYPT_BYTES = 1917;     // aead.encrypt(bytes, bytes, bytes)
  FN_AEAD_DECRYPT_STRING = 1918;    // aead.decrypt_string(bytes, bytes, string)
  FN_AEAD_DECRYPT_BYTES = 1919;     // aead.decrypt_bytes(bytes, bytes, bytes)
  FN_KMS_ENCRYPT_STRING = 1920;     // kms.encrypt(string, string)
  FN_KMS_ENCRYPT_BYTES = 1921;      // kms.encrypt(string, bytes)
  FN_KMS_DECRYPT_STRING = 1922;     // kms.decrypt_string(string, bytes)
  FN_KMS_DECRYPT_BYTES = 1923;      // kms.decrypt_bytes(string, bytes)

  // ST_ family of functions (Geography related - (broken link))
  // Constructors
  FN_ST_GEOG_POINT = 2000;
  FN_ST_MAKE_LINE = 2001;
  FN_ST_MAKE_LINE_ARRAY = 2002;
  FN_ST_MAKE_POLYGON = 2003;
  FN_ST_MAKE_POLYGON_ORIENTED = 2004;

  // Transformations
  FN_ST_INTERSECTION = 2007;
  FN_ST_UNION = 2008;
  FN_ST_UNION_ARRAY = 2009;
  FN_ST_DIFFERENCE = 2010;
  FN_ST_UNARY_UNION = 2011;
  FN_ST_CENTROID = 2012;
  FN_ST_BUFFER = 2013;
  FN_ST_BUFFER_WITH_TOLERANCE = 2014;
  FN_ST_SIMPLIFY = 2015;
  FN_ST_SNAP_TO_GRID = 2016;
  FN_ST_CLOSEST_POINT = 2017;
  FN_ST_BOUNDARY = 2018;

  // Predicates
  FN_ST_EQUALS = 2020;
  FN_ST_INTERSECTS = 2021;
  FN_ST_CONTAINS = 2022;
  FN_ST_COVERS = 2023;
  FN_ST_DISJOINT = 2024;
  FN_ST_INTERSECTS_BOX = 2025;
  FN_ST_DWITHIN = 2026;
  FN_ST_WITHIN = 2027;
  FN_ST_COVEREDBY = 2028;
  FN_ST_TOUCHES = 2029;

  // Accessors
  FN_ST_IS_EMPTY = 2030;
  FN_ST_IS_COLLECTION = 2031;
  FN_ST_DIMENSION = 2032;
  FN_ST_NUM_POINTS = 2033;
  FN_ST_DUMP = 2064;

  // Measures
  FN_ST_LENGTH = 2040;
  FN_ST_PERIMETER = 2041;
  FN_ST_AREA = 2042;
  FN_ST_DISTANCE = 2043;
  FN_ST_MAX_DISTANCE = 2044;

  // Parsers/formatters
  FN_ST_GEOG_FROM_TEXT = 2050;
  FN_ST_GEOG_FROM_KML = 2051;
  FN_ST_GEOG_FROM_GEO_JSON = 2052;
  FN_ST_GEOG_FROM_WKB = 2056;
  FN_ST_AS_TEXT = 2053;
  FN_ST_AS_KML = 2054;
  FN_ST_AS_GEO_JSON = 2055;
  FN_ST_AS_BINARY = 2057;
  FN_ST_GEOHASH = 2058;
  FN_ST_GEOG_POINT_FROM_GEOHASH = 2059;

  // Aggregate functions
  FN_ST_UNION_AGG = 2061;
  FN_ST_ACCUM = 2062;
  FN_ST_CENTROID_AGG = 2063;

  // Other geography functions
  FN_ST_X = 2070;
  FN_ST_Y = 2071;
}
